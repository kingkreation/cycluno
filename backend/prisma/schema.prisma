generator client {
  provider = "prisma-client-js"
  binaryTargets = ["native", "debian-openssl-3.0.x"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id            String    @id @default(uuid())
  email         String    @unique
  password      String
  firstName     String?
  lastName      String?
  companyName   String?
  jobTitle      String?
  userSize      String?
  isVerified    Boolean   @default(false)
  verificationToken String?
  resetToken    String?
  resetTokenExpiry DateTime?
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  products      Product[]
  testCases     TestCase[]
  bugs          Bug[]
  comments      Comment[]
  refreshTokens RefreshToken[]

  @@map("users")
}

model RefreshToken {
  id        String   @id @default(uuid())
  token     String   @unique
  userId    String
  expiresAt DateTime
  createdAt DateTime @default(now())
  
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("refresh_tokens")
}

model Product {
  id          String   @id @default(uuid())
  name        String
  description String?
  industry    String?
  platform    String?  // API, Web, Mobile
  userId      String
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  user        User       @relation(fields: [userId], references: [id], onDelete: Cascade)
  features    Feature[]
  testCases   TestCase[]
  executions  Execution[]
  bugs        Bug[]

  @@map("products")
}

model Feature {
  id          String   @id @default(uuid())
  productId   String
  name        String
  description String?
  priority    String?  // High, Medium, Low
  status      String   @default("active") // active, archived
  source      String?  // manual, prd
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  product     Product    @relation(fields: [productId], references: [id], onDelete: Cascade)
  testCases   TestCase[]

  @@map("features")
}

model TestCase {
  id            String   @id @default(uuid())
  productId     String
  featureId     String?
  testCaseId    String   @unique // e.g., TC-001
  scenario      String
  description   String?
  steps         String[] // Array of steps
  testData      String?
  expectedResult String
  priority      String   @default("Medium") // High, Medium, Low
  status        String   @default("active") // active, archived
  loggedBy      String
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  product       Product         @relation(fields: [productId], references: [id], onDelete: Cascade)
  feature       Feature?        @relation(fields: [featureId], references: [id], onDelete: SetNull)
  user          User            @relation(fields: [loggedBy], references: [id])
  executionCases ExecutionCase[]

  @@map("test_cases")
}

model Execution {
  id          String   @id @default(uuid())
  productId   String
  name        String
  description String?
  type        String   @default("standard") // standard, plugin
  status      String   @default("pending") // pending, in_progress, completed
  url         String?  // For plugin execution
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  product     Product         @relation(fields: [productId], references: [id], onDelete: Cascade)
  cases       ExecutionCase[]

  @@map("executions")
}

model ExecutionCase {
  id            String   @id @default(uuid())
  executionId   String
  testCaseId    String
  status        String   @default("Pending") // Passed, Failed, Pending
  actualResult  String?
  notes         String?
  executedAt    DateTime?
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  execution     Execution @relation(fields: [executionId], references: [id], onDelete: Cascade)
  testCase      TestCase  @relation(fields: [testCaseId], references: [id], onDelete: Cascade)
  evidences     Evidence[]
  bugs          Bug[]

  @@map("execution_cases")
}

model Evidence {
  id              String   @id @default(uuid())
  executionCaseId String
  fileName        String
  fileUrl         String
  fileType        String
  fileSize        Int
  uploadedAt      DateTime @default(now())

  executionCase   ExecutionCase @relation(fields: [executionCaseId], references: [id], onDelete: Cascade)

  @@map("evidences")
}

model Bug {
  id                String   @id @default(uuid())
  productId         String
  executionCaseId   String?
  bugId             String   @unique // e.g., BUG-001
  title             String
  description       String
  stepsToReproduce  String[]
  expectedResult    String
  actualResult      String
  possibleSolution  String?
  priority          String   @default("Medium") // Critical, High, Medium, Low
  status            String   @default("Open") // Open, Dev Refixing, Ready for Retest, Retesting, Open for Next Cycle, Fixed
  severity          String?  // Critical, Major, Minor, Trivial
  assignedTo        String?
  reportedBy        String
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  product           Product        @relation(fields: [productId], references: [id], onDelete: Cascade)
  executionCase     ExecutionCase? @relation(fields: [executionCaseId], references: [id], onDelete: SetNull)
  reporter          User           @relation(fields: [reportedBy], references: [id])
  comments          Comment[]

  @@map("bugs")
}

model Comment {
  id        String   @id @default(uuid())
  bugId     String
  userId    String
  content   String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  bug       Bug      @relation(fields: [bugId], references: [id], onDelete: Cascade)
  user      User     @relation(fields: [userId], references: [id])

  @@map("comments")
}